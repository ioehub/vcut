{
  "version": 3,
  "sources": ["../../../../../node_modules/@ffmpeg/util/dist/esm/errors.js", "../../../../../node_modules/@ffmpeg/util/dist/esm/const.js", "../../../../../node_modules/@ffmpeg/util/dist/esm/index.js"],
  "sourcesContent": ["export const ERROR_RESPONSE_BODY_READER = new Error(\"failed to get response body reader\");\nexport const ERROR_INCOMPLETED_DOWNLOAD = new Error(\"failed to complete download\");\n", "export const HeaderContentLength = \"Content-Length\";\n", "import { ERROR_RESPONSE_BODY_READER, ERROR_INCOMPLETED_DOWNLOAD, } from \"./errors.js\";\nimport { HeaderContentLength } from \"./const.js\";\nconst readFromBlobOrFile = (blob) => new Promise((resolve, reject) => {\n    const fileReader = new FileReader();\n    fileReader.onload = () => {\n        const { result } = fileReader;\n        if (result instanceof ArrayBuffer) {\n            resolve(new Uint8Array(result));\n        }\n        else {\n            resolve(new Uint8Array());\n        }\n    };\n    fileReader.onerror = (event) => {\n        reject(Error(`File could not be read! Code=${event?.target?.error?.code || -1}`));\n    };\n    fileReader.readAsArrayBuffer(blob);\n});\n/**\n * An util function to fetch data from url string, base64, URL, File or Blob format.\n *\n * Examples:\n * ```ts\n * // URL\n * await fetchFile(\"http://localhost:3000/video.mp4\");\n * // base64\n * await fetchFile(\"data:<type>;base64,wL2dvYWwgbW9yZ...\");\n * // URL\n * await fetchFile(new URL(\"video.mp4\", import.meta.url));\n * // File\n * fileInput.addEventListener('change', (e) => {\n *   await fetchFile(e.target.files[0]);\n * });\n * // Blob\n * const blob = new Blob(...);\n * await fetchFile(blob);\n * ```\n */\nexport const fetchFile = async (file) => {\n    let data;\n    if (typeof file === \"string\") {\n        /* From base64 format */\n        if (/data:_data\\/([a-zA-Z]*);base64,([^\"]*)/.test(file)) {\n            data = atob(file.split(\",\")[1])\n                .split(\"\")\n                .map((c) => c.charCodeAt(0));\n            /* From remote server/URL */\n        }\n        else {\n            data = await (await fetch(file)).arrayBuffer();\n        }\n    }\n    else if (file instanceof URL) {\n        data = await (await fetch(file)).arrayBuffer();\n    }\n    else if (file instanceof File || file instanceof Blob) {\n        data = await readFromBlobOrFile(file);\n    }\n    else {\n        return new Uint8Array();\n    }\n    return new Uint8Array(data);\n};\n/**\n * importScript dynamically import a script, useful when you\n * want to use different versions of ffmpeg.wasm based on environment.\n *\n * Example:\n *\n * ```ts\n * await importScript(\"http://localhost:3000/ffmpeg.js\");\n * ```\n */\nexport const importScript = async (url) => new Promise((resolve) => {\n    const script = document.createElement(\"script\");\n    const eventHandler = () => {\n        script.removeEventListener(\"load\", eventHandler);\n        resolve();\n    };\n    script.src = url;\n    script.type = \"text/javascript\";\n    script.addEventListener(\"load\", eventHandler);\n    document.getElementsByTagName(\"head\")[0].appendChild(script);\n});\n/**\n * Download content of a URL with progress.\n *\n * Progress only works when Content-Length is provided by the server.\n *\n */\nexport const downloadWithProgress = async (url, cb) => {\n    const resp = await fetch(url);\n    let buf;\n    try {\n        // Set total to -1 to indicate that there is not Content-Type Header.\n        const total = parseInt(resp.headers.get(HeaderContentLength) || \"-1\");\n        const reader = resp.body?.getReader();\n        if (!reader)\n            throw ERROR_RESPONSE_BODY_READER;\n        const chunks = [];\n        let received = 0;\n        for (;;) {\n            const { done, value } = await reader.read();\n            const delta = value ? value.length : 0;\n            if (done) {\n                if (total != -1 && total !== received)\n                    throw ERROR_INCOMPLETED_DOWNLOAD;\n                cb && cb({ url, total, received, delta, done });\n                break;\n            }\n            chunks.push(value);\n            received += delta;\n            cb && cb({ url, total, received, delta, done });\n        }\n        const data = new Uint8Array(received);\n        let position = 0;\n        for (const chunk of chunks) {\n            data.set(chunk, position);\n            position += chunk.length;\n        }\n        buf = data.buffer;\n    }\n    catch (e) {\n        console.log(`failed to send download progress event: `, e);\n        // Fetch arrayBuffer directly when it is not possible to get progress.\n        buf = await resp.arrayBuffer();\n        cb &&\n            cb({\n                url,\n                total: buf.byteLength,\n                received: buf.byteLength,\n                delta: 0,\n                done: true,\n            });\n    }\n    return buf;\n};\n/**\n * toBlobURL fetches data from an URL and return a blob URL.\n *\n * Example:\n *\n * ```ts\n * await toBlobURL(\"http://localhost:3000/ffmpeg.js\", \"text/javascript\");\n * ```\n */\nexport const toBlobURL = async (url, mimeType, progress = false, cb) => {\n    const buf = progress\n        ? await downloadWithProgress(url, cb)\n        : await (await fetch(url)).arrayBuffer();\n    const blob = new Blob([buf], { type: mimeType });\n    return URL.createObjectURL(blob);\n};\n"],
  "mappings": ";;;AAAO,IAAM,6BAA6B,IAAI,MAAM,oCAAoC;AACjF,IAAM,6BAA6B,IAAI,MAAM,6BAA6B;;;ACD1E,IAAM,sBAAsB;;;ACEnC,IAAM,qBAAqB,CAAC,SAAS,IAAI,QAAQ,CAAC,SAAS,WAAW;AAClE,QAAM,aAAa,IAAI,WAAW;AAClC,aAAW,SAAS,MAAM;AACtB,UAAM,EAAE,OAAO,IAAI;AACnB,QAAI,kBAAkB,aAAa;AAC/B,cAAQ,IAAI,WAAW,MAAM,CAAC;AAAA,IAClC,OACK;AACD,cAAQ,IAAI,WAAW,CAAC;AAAA,IAC5B;AAAA,EACJ;AACA,aAAW,UAAU,CAAC,UAAU;AAbpC;AAcQ,WAAO,MAAM,kCAAgC,0CAAO,WAAP,mBAAe,UAAf,mBAAsB,SAAQ,EAAE,EAAE,CAAC;AAAA,EACpF;AACA,aAAW,kBAAkB,IAAI;AACrC,CAAC;AAqBM,IAAM,YAAY,OAAO,SAAS;AACrC,MAAI;AACJ,MAAI,OAAO,SAAS,UAAU;AAE1B,QAAI,yCAAyC,KAAK,IAAI,GAAG;AACrD,aAAO,KAAK,KAAK,MAAM,GAAG,EAAE,CAAC,CAAC,EACzB,MAAM,EAAE,EACR,IAAI,CAAC,MAAM,EAAE,WAAW,CAAC,CAAC;AAAA,IAEnC,OACK;AACD,aAAO,OAAO,MAAM,MAAM,IAAI,GAAG,YAAY;AAAA,IACjD;AAAA,EACJ,WACS,gBAAgB,KAAK;AAC1B,WAAO,OAAO,MAAM,MAAM,IAAI,GAAG,YAAY;AAAA,EACjD,WACS,gBAAgB,QAAQ,gBAAgB,MAAM;AACnD,WAAO,MAAM,mBAAmB,IAAI;AAAA,EACxC,OACK;AACD,WAAO,IAAI,WAAW;AAAA,EAC1B;AACA,SAAO,IAAI,WAAW,IAAI;AAC9B;AAWO,IAAM,eAAe,OAAO,QAAQ,IAAI,QAAQ,CAAC,YAAY;AAChE,QAAM,SAAS,SAAS,cAAc,QAAQ;AAC9C,QAAM,eAAe,MAAM;AACvB,WAAO,oBAAoB,QAAQ,YAAY;AAC/C,YAAQ;AAAA,EACZ;AACA,SAAO,MAAM;AACb,SAAO,OAAO;AACd,SAAO,iBAAiB,QAAQ,YAAY;AAC5C,WAAS,qBAAqB,MAAM,EAAE,CAAC,EAAE,YAAY,MAAM;AAC/D,CAAC;AAOM,IAAM,uBAAuB,OAAO,KAAK,OAAO;AA1FvD;AA2FI,QAAM,OAAO,MAAM,MAAM,GAAG;AAC5B,MAAI;AACJ,MAAI;AAEA,UAAM,QAAQ,SAAS,KAAK,QAAQ,IAAI,mBAAmB,KAAK,IAAI;AACpE,UAAM,UAAS,UAAK,SAAL,mBAAW;AAC1B,QAAI,CAAC;AACD,YAAM;AACV,UAAM,SAAS,CAAC;AAChB,QAAI,WAAW;AACf,eAAS;AACL,YAAM,EAAE,MAAM,MAAM,IAAI,MAAM,OAAO,KAAK;AAC1C,YAAM,QAAQ,QAAQ,MAAM,SAAS;AACrC,UAAI,MAAM;AACN,YAAI,SAAS,MAAM,UAAU;AACzB,gBAAM;AACV,cAAM,GAAG,EAAE,KAAK,OAAO,UAAU,OAAO,KAAK,CAAC;AAC9C;AAAA,MACJ;AACA,aAAO,KAAK,KAAK;AACjB,kBAAY;AACZ,YAAM,GAAG,EAAE,KAAK,OAAO,UAAU,OAAO,KAAK,CAAC;AAAA,IAClD;AACA,UAAM,OAAO,IAAI,WAAW,QAAQ;AACpC,QAAI,WAAW;AACf,eAAW,SAAS,QAAQ;AACxB,WAAK,IAAI,OAAO,QAAQ;AACxB,kBAAY,MAAM;AAAA,IACtB;AACA,UAAM,KAAK;AAAA,EACf,SACO,GAAG;AACN,YAAQ,IAAI,4CAA4C,CAAC;AAEzD,UAAM,MAAM,KAAK,YAAY;AAC7B,UACI,GAAG;AAAA,MACC;AAAA,MACA,OAAO,IAAI;AAAA,MACX,UAAU,IAAI;AAAA,MACd,OAAO;AAAA,MACP,MAAM;AAAA,IACV,CAAC;AAAA,EACT;AACA,SAAO;AACX;AAUO,IAAM,YAAY,OAAO,KAAK,UAAU,WAAW,OAAO,OAAO;AACpE,QAAM,MAAM,WACN,MAAM,qBAAqB,KAAK,EAAE,IAClC,OAAO,MAAM,MAAM,GAAG,GAAG,YAAY;AAC3C,QAAM,OAAO,IAAI,KAAK,CAAC,GAAG,GAAG,EAAE,MAAM,SAAS,CAAC;AAC/C,SAAO,IAAI,gBAAgB,IAAI;AACnC;",
  "names": []
}
